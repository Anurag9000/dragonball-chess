<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DragonBall Chess — Local 2P</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Local vendor scripts (no network required) -->
  <script src="vendor/react.development.js"></script>
  <script src="vendor/react-dom.development.js"></script>
  <script src="vendor/babel.min.js"></script>
    <script>
    // Tell the loader where the .wasm lives
    window.Module = { locateFile: p => 'vendor/lichess/' + p };
    </script>
    <style>
    #bootlog {
        position: fixed;
        right: 8px;
        bottom: 8px;
        z-index: 9999;
        background: rgba(0, 0, 0, 0.7);
        color: #e2e8f0;
        font: 12px/1.4 ui-sans-serif, system-ui;
        padding: 8px 10px;
        border-radius: 8px;
        max-width: 60vw;
    }
    </style>

    <script>
    (function () {
        const box = document.createElement('div');
        box.id = 'bootlog';
        box.textContent = 'Boot: init';
        document.addEventListener('DOMContentLoaded', () => document.body.appendChild(box));
        window.__log = (...a) => {
        box.textContent = a.join(' | ');
        console.log('[DBZ]', ...a);
        };
        window.addEventListener('error', e => {
        __log('ERROR', e.message);
        });
    })();
    </script>

  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #0f172a; color: #e2e8f0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .square { aspect-ratio: 1 / 1; position: relative; }
    .light { background: #f0d9b5; }
    .dark { background: #b58863; }
    .highlight { outline: 3px solid rgba(255, 230, 0, 0.8); outline-offset: -3px; }
    .legal-dot::after {
      content: ""; width: 18px; height: 18px; border-radius: 9999px; background: rgba(0,0,0,0.18); position: absolute; inset: 0; margin: auto;
    }
    .capture-ring::after {
      content: ""; position: absolute; inset: 6px; border: 3px solid rgba(220,38,38,0.85); border-radius: 8px;
    }
    .mask { background: rgba(2,6,23,0.78); }
    /* Piece rendering: fill the square and keep label as overlay, so layout never stretches the square */
    .piece-layer {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 6%;           /* tasteful margin inside the square */
    pointer-events: none;  /* clicks go to the square */
    }

    .piece-img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    user-select: none;
    display: block;
    }

    /* Tailwind's .relative isn't available here; define it */
    .relative {
      position: relative;
    }

    .piece-badge {
    position: absolute;
    left: 0;
    right: 0;
    bottom: 4px;
    text-align: center;
    font-size: 12px;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 2px rgba(0,0,0,0.9);
    background: rgba(0,0,0,0.6);
    border-radius: 9999px;
    padding: 2px 6px;
    max-width: 90%;
    margin: 0 auto;
    pointer-events: none;
    backdrop-filter: blur(3px);

    /* color: rgba(226, 232, 240, 0.95); */
    pointer-events: none;
    }

    /* --- Team visuals --- */
    .team-w .piece-img {
    /* soft blue aura for White */
    filter: drop-shadow(0 0 6px rgba(96,165,250,0.9))
    drop-shadow(0 0 16px rgba(147,197,253,0.7));
    }

    .team-b .piece-img {
    /* soft red aura for Black */
    filter: drop-shadow(0 0 6px rgba(248,113,113,0.9))
    drop-shadow(0 0 16px rgba(254,202,202,0.7));
    }

    .team-ring {
    position: absolute;
    inset: 5px;
    border-radius: 10px;
    pointer-events: none;
    }

    .team-w .team-ring {
    border: 3px solid rgba(59,130,246,0.85);
    box-shadow: 0 0 10px rgba(59,130,246,0.45) inset;
    }

    .team-b .team-ring {
    border: 3px solid rgba(239,68,68,0.85);
    box-shadow: 0 0 10px rgba(239,68,68,0.45) inset;
    }

    .team-w .piece-badge {
    background: rgba(59,130,246,0.22);
    border-radius: 9999px;
    display: inline-block;
    padding: 2px 6px;
    }

    .team-b .piece-badge {
    background: rgba(239,68,68,0.22);
    border-radius: 9999px;
    display: inline-block;
    padding: 2px 6px;
    }

    .pulse { animation: pulseScale 320ms ease-out; }
    @keyframes pulseScale {
      0% { transform: scale(0.82); opacity: 0.65; filter: saturate(0.6) brightness(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }

    /* Minimal layout so Tailwind is not required */
    .container { max-width: 1080px; margin: 0 auto; padding: 16px; display: grid; gap: 16px; grid-template-columns: 1fr 320px; }
    .card { background: rgba(30,41,59,0.4); border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
    .board { display: grid; grid-template-columns: repeat(8, 1fr); border: 4px solid #334155; border-radius: 12px; overflow: hidden; }
    .btn { background:#334155; color:#e2e8f0; border:0; border-radius:10px; padding:8px 12px; cursor:pointer; }
    .btn:hover { background:#475569; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .status { font-size: 14px; opacity: 0.9; }
    .stack { display:grid; gap:16px; }
    /* Overlay canvas that truly fills the board (no Tailwind needed) */
    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .overlay > canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

  </style>
</head>
<body>
  <div id="root" class="min-h-full flex items-center justify-center p-4"></div>

  <!-- App -->
  <script type="text/babel" data-presets="env,react">
    window.bootDBZ = function () {
      if (!window.Chess) { __log('bootDBZ called but Chess missing'); }
      if (!window.React || !window.ReactDOM) { __log('React/ReactDOM missing'); }

      const { useState, useEffect, useRef } = React;

      // ---------- Helpers ----------
      const FILES = ['a','b','c','d','e','f','g','h'];
      const RANKS = [8,7,6,5,4,3,2,1];
      const isDark = (fileIdx, rankIdx) => (fileIdx + rankIdx) % 2 !== 0;

      // DBZ forms (expand later with sprites)
      const FORMS = {
        goku: ['base', 'kaioken', 'ssj','ssj2','ssj3', 'ssj4', 'ssg', 'ssb', 'ssb_kaioken', 'ui','mui'],
        vegeta: ['base','great_ape', 'ssj','ssj2','ssj3', 'ssj4', 'ssg', 'ssb', 'ssb_evolved', 'ultra_ego'],
        zeno: ['zeno'],
        whis: ['angel'],
        grand_priest: ['grand_priest'],
        piccolo: ['base','potential','orange'],
        krillin: ['base'],
        yamcha: ['base'],
        tien: ['base'],
        chiaotzu: ['base'],
        android_18: ['base'],
        majin_boo: ['fat','evil','super','buutenks','buuccolo','buuhan','kid_buu'],
        frieza: ['1','2','3','final','mecha','golden','black'],
        saibaman: ['base'],
        gohan_kid: ['base','ssj','ssj2', 'ssj3', 'mystic', 'beast'],
        gotenks: ['base','ssj', 'ssj2', 'ssj3'],
      };

      function spriteUrl(char, formKey) { return `assets/pieces/${char}/${formKey}.png`; }

      // --- Strict mapping guards: which chess piece is which DBZ character ---
      // Allowed characters per chess TYPE (k,q,r,b,n,p)
      const TYPE_ALLOWED = {
        k: new Set(['zeno']),
        q: new Set(['grand_priest']),
        r: new Set(['goku','vegeta']),
        b: new Set(['majin_boo','gotenks']),
        n: new Set(['gohan_kid','frieza']),
        p: new Set(['saibaman','chiaotzu','krillin','tien','whis','yamcha','piccolo','android_18']),
      };

      const PAWN_FILES_DEFAULT = ['saibaman','chiaotzu','krillin','tien','whis','yamcha','piccolo','android_18']; // a..h

      function clampForm(char, formIdx) {
        const forms = FORMS[char] ?? ['base'];
        const idx = Math.min(Math.max(0, formIdx|0), forms.length - 1);
        return { forms, formIdx: idx };
      }

      /**
       * Normalize/repair the DBZ roster so every chess piece type strictly maps to
       * its allowed DBZ character set. Keeps life/kills; fixes char & forms if needed.
       * Returns [normalizedMap, changed:boolean]
       */
      function ensureMappingStrict(chess, rosterMap) {
        const out = new Map();
        let changed = false;

        // 1) Pass: for every board square with a piece, ensure a valid roster entry
        for (const f of FILES) {
          for (const r of RANKS) {
            const sq = `${f}${r}`;
            const p = chess.get(sq);
            if (!p) continue;

            const allowed = TYPE_ALLOWED[p.type] || new Set();
            let dbz = rosterMap.get(sq);

            if (!dbz) {
              // Create a default mapping for this type if missing
              let char = 'grand_priest';
              if (p.type === 'k') char = 'zeno';
              else if (p.type === 'q') char = 'grand_priest';
              else if (p.type === 'r') char = 'goku';
              else if (p.type === 'b') char = 'majin_boo';
              else if (p.type === 'n') char = 'gohan_kid';
              else if (p.type === 'p') {
                const fileIdx = FILES.indexOf(f);
                char = PAWN_FILES_DEFAULT[fileIdx] || 'saibaman';
              }
              const { forms, formIdx } = clampForm(char, 0);
              dbz = { id: `${p.color}_${char}_${Math.random().toString(36).slice(2,9)}`, color: p.color, char, life: 0, kills: 0, forms, formIdx };
              changed = true;
            } else {
              // Has roster entry; make sure its char is legal for this chess type
              let char = dbz.char;
              if (!allowed.has(char)) {
                // Force to the canonical character of that type, preserving life/kills
                if (p.type === 'k') char = 'zeno';
                else if (p.type === 'q') char = 'grand_priest';
                else if (p.type === 'r') char = ['goku','vegeta'].includes(dbz.char) ? dbz.char : 'goku';
                else if (p.type === 'b') char = ['majin_boo','gotenks'].includes(dbz.char) ? dbz.char : 'majin_boo';
                else if (p.type === 'n') char = ['gohan_kid','frieza'].includes(dbz.char) ? dbz.char : 'gohan_kid';
                else if (p.type === 'p') {
                  if (!TYPE_ALLOWED.p.has(char)) {
                    const fileIdx = FILES.indexOf(f);
                    char = PAWN_FILES_DEFAULT[fileIdx] || 'saibaman';
                  }
                }
                const { forms, formIdx } = clampForm(char, dbz.formIdx ?? 0);
                dbz = { ...dbz, char, forms, formIdx };
                changed = true;
              } else {
                // allowed char: just clamp forms in case assets changed
                const { forms, formIdx } = clampForm(char, dbz.formIdx ?? 0);
                if (forms !== dbz.forms || formIdx !== dbz.formIdx) {
                  dbz = { ...dbz, forms, formIdx };
                  changed = true;
                }
              }
              // Keep color in sync with chess piece color (safety)
              if (dbz.color !== p.color) { dbz = { ...dbz, color: p.color }; changed = true; }
            }
            out.set(sq, dbz);
          }
        }

        // 2) Any roster entries that no longer have a chess piece at that square are dropped.
        // (implicit by rebuilding 'out' from the board)

        return [out, changed];
      }

      function initialRoster() {
        const m = new Map(); // square -> PieceState
        // White back rank (a1..h1):
        // R: Goku, N: Gohan Kid, B: Majin Boo, Q: Grand Priest, K: Zeno, B: Gotenks, N: Frieza, R: Vegeta
        m.set('a1', mk('w','goku'));         // rook
        m.set('b1', mk('w','gohan_kid'));    // knight
        m.set('c1', mk('w','majin_boo'));    // bishop
        m.set('d1', mk('w','grand_priest')); // queen
        m.set('e1', mk('w','zeno'));         // king
        m.set('f1', mk('w','gotenks'));      // bishop
        m.set('g1', mk('w','frieza'));       // knight
        m.set('h1', mk('w','vegeta'));       // rook

        // White pawns (a2..h2):
        // Saibaman, Chiaotzu, Krillin, Tien, Whis, Yamcha, Piccolo, Android 18
        ['a2','b2','c2','d2','e2','f2','g2','h2'].forEach((sq, i) => {
        const order = ['saibaman','chiaotzu','krillin','tien','whis','yamcha','piccolo','android_18'];
        m.set(sq, mk('w', order[i]));
        });

        // Black back rank (a8..h8) mirrored with same mapping
        m.set('a8', mk('b','goku'));         // rook
        m.set('b8', mk('b','gohan_kid'));    // knight
        m.set('c8', mk('b','majin_boo'));    // bishop
        m.set('d8', mk('b','grand_priest')); // queen
        m.set('e8', mk('b','zeno'));         // king
        m.set('f8', mk('b','gotenks'));      // bishop
        m.set('g8', mk('b','frieza'));       // knight
        m.set('h8', mk('b','vegeta'));       // rook

        // Black pawns (a7..h7) same order as white
        ['a7','b7','c7','d7','e7','f7','g7','h7'].forEach((sq, i) => {
        const order = ['saibaman','chiaotzu','krillin','tien','whis','yamcha','piccolo','android_18'];
        m.set(sq, mk('b', order[i]));
        });

        return m;

        function mk(color, char) {
          const forms = FORMS[char] ?? ['base'];
          return { id: `${color}_${char}_${Math.random().toString(36).slice(2,9)}`, color, char, life: 0, kills: 0, formIdx: 0, forms };
        }
      }

      // ---------- Main App ----------
      function App() {
        // Chess & game state
        const [game, setGame] = useState(() => new Chess());
        const [roster, setRoster] = useState(() => initialRoster());
        const [selected, setSelected] = useState(null);
        const [legal, setLegal] = useState(new Set());
        const [status, setStatus] = useState('');
        const fenBefore = useRef('');

        // UI helpers
        const [toast, setToast] = useState(null);
        const [fog, setFog] = useState(false);
        const trailRef = useRef(null);
        // Normalize guards: run after every position change to enforce strict mapping
        useEffect(() => {
          // Delay one tick to allow pending roster setState to land, then normalize
          const t = setTimeout(() => {
            setRoster(prev => {
              const [norm, changed] = ensureMappingStrict(game, prev);
              if (changed) __log('Roster normalized to strict mapping');
              return changed ? norm : prev;
            });
          }, 0);
          return () => clearTimeout(t);
        }, [game]); // whenever the chess position changes

        // Also enforce once on boot
        useEffect(() => { setRoster(prev => ensureMappingStrict(game, prev)[0]); }, []);

        // DBZ-aware undo
        const historyRef = useRef([]); // stack of { fenBefore, rosterBefore }
        // --------- AI / Stockfish state ----------
        const [aiWhite, setAiWhite] = useState(false);
        const [aiBlack, setAiBlack] = useState(false);
        // Single Hardness selector that maps to Elo & timing
        const [hardness, setHardness] = useState('Normal'); // 'Easy' | 'Normal' | 'Hard' | 'Insane'
        function hardnessProfile(h) {
          if (h === 'Easy')   return { elo: 1000, movetime: 500, depth: 8,  hash: 8 };
          if (h === 'Hard')   return { elo: 2000, movetime: 900, depth: 16, hash: 16 };
          if (h === 'Insane') return { elo: 2600, movetime: 1300, depth: 22, hash: 32 };
          return              { elo: 1500, movetime: 700, depth: 12, hash: 12 }; // Normal
        }

        const [engineReady, setEngineReady] = useState(false);
        const [engineThinks, setEngineThinks] = useState(false);
        const engineRef = useRef(null);            // Lichess Stockfish instance
        const engineBuf = useRef([]);              // optional logs
        const pendingBest = useRef(null);
        const thinkWatchdog = useRef(null);
        const engineBooting = useRef(false);       // re-entrancy guard
        const [capturedByWhite, setCapturedByWhite] = useState([]); // pieces White captured (types)
        const [capturedByBlack, setCapturedByBlack] = useState([]); // pieces Black captured

        function post(s) {
          try { engineRef.current?.postMessage(s); }
          catch (e) { logEngine('ERR', `post fail: ${e?.message || e}`); }
        }

        function logEngine(side, text) {
          const line = `[${new Date().toLocaleTimeString()}] ${side}: ${text}`;
          engineBuf.current.push(line);
          if (engineBuf.current.length > 60) engineBuf.current.splice(0, engineBuf.current.length - 60);
          __log(text);
        }

        useEffect(() => { refreshStatus(); maybeEngineTurn();}, []);

        function refreshStatus() {
        if (game.isGameOver()) {
            // Status text
            if (game.isCheckmate()) {
            setStatus(`Checkmate — ${game.turn() === 'w' ? 'Black' : 'White'} wins`);
            } else if (game.isStalemate()) {
            setStatus('Stalemate');
            } else if (game.isDraw()) {
            setStatus('Draw');
            } else {
            setStatus('Game over');
            }

            // Cleanly stop / tear down engine once
            try { post('stop'); } catch (_) {}
            try { engineRef.current?.terminate?.(); } catch (_) {}
            engineRef.current = null;
            pendingBest.current = null;
            setEngineThinks(false);
            if (thinkWatchdog.current) { clearTimeout(thinkWatchdog.current); thinkWatchdog.current = null; }
            setEngineReady(false);
            return; // done
        }

        // Not over: normal status
        const t = game.turn() === 'w' ? 'White' : 'Black';
        const flags = [ game.isCheck() ? 'Check' : null ].filter(Boolean).join(' • ');
        setStatus(`${t} to move${flags ? ' — ' + flags : ''}`);
        }


        function flashNotice(msg) { setToast(msg); setTimeout(() => setToast(null), 1200); }

        // --- Attack line (blue for current player / white, red for opponent / black) ---
        function drawAttackLine(move, attackerColor) {
        if (!trailRef.current) return;

        const canvas = trailRef.current;
        const rect = canvas.getBoundingClientRect(); // actual drawn area
        const w = rect.width;
        const h = rect.height;

        const dpr = window.devicePixelRatio || 1;
        canvas.width  = Math.max(1, Math.round(w * dpr));
        canvas.height = Math.max(1, Math.round(h * dpr));

        const ctx = canvas.getContext('2d');
        // 1 CSS pixel == 1 unit in our math
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, w, h);

          // Account for the board's CSS border (4px in your stylesheet)
          const border = 4;
          const innerW = Math.max(0, w - border * 2);
          const innerH = Math.max(0, h - border * 2);

          // Board may not be perfectly square inside the card; derive per-axis sizes
          const sqW = innerW / 8;
          const sqH = innerH / 8;

        const fromFile = FILES.indexOf(move.from[0]);
        const fromRank = 8 - parseInt(move.from[1], 10);
        const toFile   = FILES.indexOf(move.to[0]);
        const toRank   = 8 - parseInt(move.to[1], 10);

        const cx = f => border + f * sqW + sqW / 2;
        const cy = r => border + r * sqH + sqH / 2;

        ctx.strokeStyle = attackerColor === 'w' ? '#38bdf8' : '#ef4444';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.shadowColor = ctx.strokeStyle;
        ctx.shadowBlur = 12;

        ctx.beginPath();
        ctx.moveTo(cx(fromFile), cy(fromRank));
        ctx.lineTo(cx(toFile),   cy(toRank));
        ctx.stroke();

        setTimeout(() => { ctx.clearRect(0, 0, w, h); }, 700);
        }

        // --- Material / Captures helpers (traditional values, K excluded) ---
        const PIECE_VALUE = { p:1, n:3, b:3, r:5, q:9 };
        function materialScore(game) {
          let w = 0, b = 0;
          for (const row of game.board()) for (const cell of row) {
            if (!cell) continue;
            const v = PIECE_VALUE[cell.type] || 0;
            if (cell.color === 'w') w += v; else b += v;
          }
          return { w, b, diff: w - b };
        }

        // --- History helpers ---
        function pushHistory(fenBefore) {
          historyRef.current.push({ fenBefore, rosterBefore: new Map(roster) });
        }
        function popHistory() {
          const entry = historyRef.current.pop();
          if (!entry) return false;
          // Restore then normalize to guarantee strict mapping
          const g = new Chess(entry.fenBefore);
          const [norm] = ensureMappingStrict(g, entry.rosterBefore);
          setGame(g);
          setRoster(norm);
          setCapturedByWhite([]);
          setCapturedByBlack([]);
          setSelected(null); setLegal(new Set());
          return true;
        }
        
        function toggleTurnFen(fen, attackerColor) {
        // fen: <piece placement> <activeColor> <castling> <ep> <halfmove> <fullmove>
        const parts = fen.split(' ');
        if (parts.length < 6) return fen;
        const wasBlack = attackerColor === 'b';
        parts[1] = parts[1] === 'w' ? 'b' : 'w';
        // Increment fullmove count only after a black action completes (mirrors chess FEN)
        if (wasBlack) parts[5] = String(parseInt(parts[5], 10) + 1);
        return parts.join(' ');
        }

        // --- Input handling ---
        function onSquareClick(sq) {
          if (selected === null) {
            const p = game.get(sq); if (!p) return; if (p.color !== game.turn()) return;
            setSelected(sq);
            const moves = game.moves({ square: sq, verbose: true }).map(m => m.to);
            setLegal(new Set(moves));
            fenBefore.current = game.fen();
            return;
          }
          const pieceAt = game.get(sq);
          if (pieceAt && pieceAt.color === game.turn()) {
            setSelected(sq);
            const moves = game.moves({ square: sq, verbose: true }).map(m => m.to);
            setLegal(new Set(moves));
            fenBefore.current = game.fen();
            return;
          }
          if (legal.has(sq)) doMove(selected, sq);
          setSelected(null); setLegal(new Set());
        }

        // --- Core move pipeline (DBZ rules + chess.js) ---
        function doMove(from, to, promotion) {
          const beforeFEN = fenBefore.current || game.fen();
          pushHistory(beforeFEN);

          const attempted = game.move({ from, to, promotion: promotion || 'q' });
          if (!attempted) { setGame(new Chess(game.fen())); historyRef.current.pop(); return; }
          const wasCapture = !!attempted.captured || attempted.flags.includes('e');
          const isPromotion = !!attempted.promotion;

          // En passant defender square
          let defenderSquare = to;
          if (attempted.flags.includes('e')) {
            defenderSquare = attempted.color === 'w' ? to[0] + (parseInt(to[1]) - 1) : to[0] + (parseInt(to[1]) + 1);
          }

          if (!wasCapture) {
            // Handle castling (quiet move where chess.js moved king & rook on the board).
            // We must mirror the rook move inside our DBZ roster.
            if (attempted.flags.includes('k') || attempted.flags.includes('q')) {
              const isWhite = attempted.color === 'w';
              const isKingSide = attempted.flags.includes('k');

              const rookFrom = isKingSide
                  ? (isWhite ? 'h1' : 'h8')
                  : (isWhite ? 'a1' : 'a8');
              const rookTo = isKingSide
                  ? (isWhite ? 'f1' : 'f8')
                  : (isWhite ? 'd1' : 'd8');

              setRoster(prev => {
                  const m = new Map(prev);
                  // move king in roster
                  const king = m.get(from);
                  if (king) { m.delete(from); m.set(to, king); }
                  // move rook in roster
                  const rook = m.get(rookFrom);
                  if (rook) { m.delete(rookFrom); m.set(rookTo, rook); }
                  return m;
              });
              refreshStatus();
              setTimeout(maybeEngineTurn, 0);
              return;
            }

            // Handle promotion reskin if happened on a quiet move
            if (isPromotion) {
            const moverChar = roster.get(from)?.char; // capture before state change
            setRoster(prev => {
                const moverPrev = prev.get(from);
                if (!moverPrev) return prev;
                const promoted = {
                ...moverPrev,
                char: 'grand_priest',
                forms: ['grand_priest'],
                formIdx: 0,
                };
                const m = new Map(prev);
                m.delete(from);
                m.set(to, promoted);
                return m;
            });
            refreshStatus();
            setTimeout(maybeEngineTurn, 0); // avoid racing this update
            return;
            }

            // Regular quiet move
            syncRosterOnMove(from, to);
            refreshStatus(); maybeEngineTurn(); return;
          }

          // Capture handling — check downgrade rule
          const defenderState = roster.get(defenderSquare);
          if (defenderState && defenderState.life > 0) {
            drawAttackLine({ from, to: defenderSquare }, attempted.color);
            const downgraded = { ...defenderState };
            downgraded.life = Math.max(0, downgraded.life - 1);
            downgraded.formIdx = Math.max(0, downgraded.formIdx - 1);

            setRoster(prev => {
              const m = new Map(prev);
              m.set(defenderSquare, downgraded);
              return m;
            });
            // Restore board to pre-move position but flip turn to the opponent.
            const toggledFen = toggleTurnFen(beforeFEN, attempted.color);
            const reverted = new Chess(toggledFen);
            setGame(reverted);

            flashNotice(`Downgrade! ${defenderState.char.toUpperCase()} loses a form — turn passes.`);
            refreshStatus();
            setTimeout(() => { if (!engineThinks) maybeEngineTurn(); }, 0);
            return;

          }

          // Defender at base — proceed with capture, attacker upgrades
          const moverState = roster.get(from);
          if (moverState) {
            drawAttackLine({ from, to: defenderSquare }, attempted.color);
            const boosted = { ...moverState };
            const defenderKills = defenderState?.kills || 0;
            boosted.life += defenderKills + 1; // opponent's kills + 1
            boosted.kills = (boosted.kills || 0) + 1; // record this kill; 

           if (boosted.formIdx < boosted.forms.length - 1) boosted.formIdx += 1;
           if (isPromotion) { boosted.char = 'grand_priest'; boosted.forms = ['grand_priest']; boosted.formIdx = 0; }

            setRoster(prev => {
            const m = new Map(prev);
            m.delete(from); m.set(to, boosted);
            if (attempted.flags.includes('e')) m.delete(defenderSquare);
            return m;
            });
            // Update capture lists (who gained what)
            const capType = attempted.captured || (attempted.flags.includes('e') ? 'p' : null);
            if (capType) {
              if (attempted.color === 'w') {
                setCapturedByWhite(prev => [...prev, capType]);
              } else {
                setCapturedByBlack(prev => [...prev, capType]);
              }
            }

          } else {
            syncRosterOnMove(from, to);
          }
          flashNotice('Power up!');
          refreshStatus(); maybeEngineTurn();
        }

        function syncRosterOnMove(from, to) {
          setRoster(prev => {
            const st = prev.get(from); if (!st) return prev;
            const m = new Map(prev);
            m.delete(from); m.set(to, st);
            return m;
          });
        }
        // ---------- ENGINE WIRING ----------
        function isAiTurn() {
          const t = game.turn();
          return (t === 'w' && aiWhite) || (t === 'b' && aiBlack);
        }

        function bootEngine() {
        // Guard against re-entrancy while UCI init is in flight
        if (engineBooting.current) return;
        engineBooting.current = true;

        // Cleanly terminate any previous worker to avoid multiple WASM heaps
        try { engineRef.current?.terminate?.(); } catch (_) {}
        engineRef.current = null;

        // Reset engine state
        setEngineReady(false);
        setEngineThinks(false);
        pendingBest.current = null;
        if (thinkWatchdog.current) { clearTimeout(thinkWatchdog.current); thinkWatchdog.current = null; }
        engineBuf.current = [];

        // Spawn Stockfish strictly as a WebWorker (no main-thread instance)
        let eng = null;
        try {
            eng = new Worker('vendor/lichess/stockfish-17-lite-single.js');
        } catch (err) {
            logEngine('ERR', `Engine spawn failed: ${err?.message || err}`);
            engineBooting.current = false;
            return;
        }
        engineRef.current = eng;

        eng.onmessage = (e) => {
            const line = (typeof e.data === 'string') ? e.data : (e.data?.data ?? '');
            if (!line) return;
            engineBuf.current.push(line);
            logEngine('ENG', line);

            if (line === 'uciok') {
            // single-thread build ignores Threads; Hash/Elo are fine
            const prof = hardnessProfile(hardness);
            post(`setoption name Hash value ${Math.max(1, Math.min(prof.hash, 32))}`);
            post('isready');
            } else if (line === 'readyok') {
            setEngineReady(true);
            engineBooting.current = false; // allow future restarts
            maybeEngineTurn();
            } else if (line.startsWith('bestmove')) {
            const parts = line.trim().split(/\s+/);
            const uci = parts[1];
            setEngineThinks(false);
            if (thinkWatchdog.current) { clearTimeout(thinkWatchdog.current); thinkWatchdog.current = null; }

            // End of game: engine reports no legal move
            if (!uci || uci === '(none)' || uci === '0000') {
                pendingBest.current = null;
                refreshStatus();    // will show checkmate/stalemate/draw
                return;
            }

            pendingBest.current = uci;
            applyBestMove();
            }

        };

        eng.onerror = (err) => {
            logEngine('ERR', `Engine worker error: ${err?.message || err}`);
            engineBooting.current = false;
            // Try a clean restart next tick
            try { engineRef.current?.terminate?.(); } catch (_) {}
            engineRef.current = null;
            setEngineReady(false);
            setEngineThinks(false);
            setTimeout(() => bootEngine(), 50);
        };

        // Kick off UCI handshake
        post('uci');
        }
        function applyStrengthFor(color) {
          const prof = hardnessProfile(hardness);
          const elo = prof.elo;
          if (!engineRef.current) return;
          post(`setoption name UCI_LimitStrength value true`);
          post(`setoption name UCI_Elo value ${elo}`);
          // Fallback skill level mapping (some builds still accept it)
          const skill = Math.min(20, Math.max(0, Math.round((elo - 800) / 100)));
          post(`setoption name Skill Level value ${skill}`);
        }

        function enginePositionAndGo() {
          if (!engineRef.current || !engineReady) return;
          if (engineThinks) return; // don’t overlap searches
          // Think only for the side to move that is AI-controlled
          const t = game.turn();
          if ((t === 'w' && !aiWhite) || (t === 'b' && !aiBlack)) return;
          // Always send a STOP to clear any previous analysis safely
          post('stop');

          const fen = game.fen();
          applyStrengthFor(t);

          // Keep memory light before starting search
          const prof = hardnessProfile(hardness);
          post(`setoption name Hash value ${Math.max(1, Math.min(prof.hash, 32))}`);
          // Optional: flip NNUE off for low-RAM devices
          // post('setoption name Use NNUE value false');

          post(`position fen ${fen}`);
          if (prof.movetime && prof.movetime > 0) {
            post(`go movetime ${prof.movetime}`);
          } else {
            post(`go depth ${prof.depth}`);
          }
          setEngineThinks(true);
        }

        function applyBestMove() {
          const uci = pendingBest.current;
          if (!uci || game.isGameOver()) return;

          const from = uci.slice(0, 2);
          const to   = uci.slice(2, 4);
          const prom = uci.length > 4 ? uci[4] : undefined;

          // Sanity: only apply if still legal in the current position
          const legalNow = game.moves({ verbose: true }).some(m =>
            m.from === from && m.to === to && (!m.promotion || m.promotion === prom)
          );
          if (!legalNow) {
            console.warn('[DBZ] Desync: engine suggested illegal move', uci, 'for', game.fen());
            pendingBest.current = null;
            setEngineThinks(false);
            setTimeout(enginePositionAndGo, 0); // re-sync and think again
            return;
          }

          doMove(from, to, prom);
          pendingBest.current = null;

          const aivai = aiWhite && aiBlack;
          if (aivai && !game.isGameOver()) {
            setTimeout(enginePositionAndGo, 50);
          }
        }

        function maybeEngineTurn() {
          if (!isAiTurn()) return;
          if (!engineRef.current) { bootEngine(); return; }
          if (!engineReady) return;
          // Only trigger a new search if we’re idle
          if (!engineThinks) enginePositionAndGo();
        }

        // Reconfigure on difficulty/limits change
        useEffect(() => {
          if (!engineRef.current) { bootEngine(); return; }
          // Restart with new settings, but terminate the old worker first
          bootEngine();
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [hardness]);
        // If mode changes, possibly hand turn to engine
        useEffect(() => { maybeEngineTurn(); /* eslint-disable-next-line */ }, [aiWhite, aiBlack, game, roster]);
        useEffect(() => {
          return () => { try { engineRef.current?.terminate?.(); } catch (_) {} };
        }, []);
        // ---- UI ----
        return (
          <div className="container">
            <div className="card">
              <div style={{fontSize:'20px', fontWeight:600, marginBottom:'12px'}}>DragonBall Chess</div>
              <div className="relative">
                <Board game={game} roster={roster} selected={selected} legal={legal} fog={fog} onSquareClick={onSquareClick} />
                <div className="overlay">
                  <canvas ref={trailRef} />
                </div>
                {engineThinks && (
                  <div
                    style={{
                      position: 'absolute',
                      right: '8px',
                      top: '8px',
                      background: 'rgba(2,6,23,0.7)',
                      padding: '6px 10px',
                      borderRadius: '10px',
                      fontSize: '12px'
                    }}
                  >
                    Stockfish thinking…
                  </div>
                )}

              </div>
              <div className="row" style={{marginTop:'16px', justifyContent:'space-between'}}>
                <div className="status">{status}</div>
                <div className="row">
                  <button className="btn" onClick={() => {
                    const g = new Chess();
                    setGame(g); setRoster(initialRoster());
                    setSelected(null); setLegal(new Set());
                    setCapturedByWhite([]); setCapturedByBlack([]);
                    historyRef.current = []; refreshStatus(); maybeEngineTurn();
                  }}>Restart</button>
                  <button className="btn" onClick={() => setFog(f => !f)}>{fog ? 'Fog: ON' : 'Fog: OFF'}</button>
                  <button className="btn" onClick={() => {
                    if (!popHistory()) return;
                    // mapping normalized by the [game] effect
                    refreshStatus();
                    maybeEngineTurn();
                  }}>Undo</button>

                </div>
              </div>
            </div>

            <aside className="stack">
            <Panel title="Engine Log">
              <div style={{fontSize:12, maxHeight:180, overflow:'auto', background:'#0b1220', padding:8, borderRadius:8}}>
                {(engineBuf.current || []).map((l,i) => <div key={i} style={{whiteSpace:'pre-wrap'}}>{l}</div>)}
              </div>
              <div style={{fontSize:12, opacity:.9, marginTop:6}}>
                Ready: <b>{String(engineReady)}</b> · Thinking: <b>{String(engineThinks)}</b><br/>
                FEN: <code style={{fontSize:11}}>{game.fen()}</code>
              </div>
            </Panel>

            <Panel title="Score & Captures">
              {(() => {
                const ms = materialScore(game);
                const pieceGlyph = t => ({p:'♙',n:'♘',b:'♗',r:'♖',q:'♕'}[t] || t);
                return (
                  <div style={{ fontSize: 13, lineHeight: 1.6 }}>
                    <div><b>Material</b> — White: {ms.w} • Black: {ms.b} • Diff: {ms.diff > 0 ? `+${ms.diff}` : ms.diff}</div>
                    <div className="row"><b>White gained:</b>&nbsp;{capturedByWhite.length ? capturedByWhite.map((t,i)=><span key={i} style={{marginRight:6}}>{pieceGlyph(t)}</span>) : <i>—</i>}</div>
                    <div className="row"><b>Black gained:</b>&nbsp;{capturedByBlack.length ? capturedByBlack.map((t,i)=><span key={i} style={{marginRight:6}}>{pieceGlyph(t)}</span>) : <i>—</i>}</div>
                  </div>
                );
              })()}
            </Panel>

            <Panel title="Engine">
              <div className="row" style={{ alignItems: 'center' }}>
                <label style={{ fontSize: 12, opacity: 0.9, width: 90 }}>AI as White</label>
                <input type="checkbox" checked={aiWhite} onChange={e => setAiWhite(e.target.checked)} />
              </div>
              <div className="row" style={{ alignItems: 'center' }}>
                <label style={{ fontSize: 12, opacity: 0.9, width: 90 }}>AI as Black</label>
                <input type="checkbox" checked={aiBlack} onChange={e => setAiBlack(e.target.checked)} />
              </div>
              <div className="row" style={{ alignItems: 'center', marginTop: 8 }}>
                <label style={{ fontSize: 12, opacity: 0.9, width: 90 }}>Hardness</label>
                <select className="btn" value={hardness} onChange={e => setHardness(e.target.value)}>
                  <option>Easy</option>
                  <option>Normal</option>
                  <option>Hard</option>
                  <option>Insane</option>
                </select>
                <button className="btn" onClick={bootEngine} disabled={engineThinks} style={{ marginLeft: 8 }}>Apply</button>
              </div>
              <div style={{ fontSize: 12, opacity: 0.85, marginTop: 6 }}>
                Engine strength & think time auto-tuned by Hardness.
              </div>

            </Panel>

            <Panel title="Turn / State">
                <div className="text-sm leading-relaxed">
                <div><b>Side:</b> {game.turn() === 'w' ? 'White' : 'Black'}</div>
                <div><b>Check:</b> {game.isCheck() ? 'Yes' : 'No'}</div>
                <div><b>Stalemate:</b> {game.isStalemate() ? 'Yes' : 'No'}</div>
                <div><b>Castling Rights:</b> <code style={{ fontSize: '12px' }}>{game.fen().split(' ')[2]}</code></div>
                <div><b>En Passant:</b> <code style={{ fontSize: '12px' }}>{game.fen().split(' ')[3]}</code></div>
                </div>
            </Panel>

            <Panel title="DBZ Rules (active)">
                <ul style={{ paddingLeft: '18px', fontSize: '14px', lineHeight: 1.5 }}>
                <li>On kill: attacker <b>life+1</b> & transforms.</li>
                <li>On hit when defender has life &gt; 0: defender <b>life-1</b>, positions unchanged, <b>turn passes to the opponent</b>.</li>
                <li>Base defender on hit: captured normally.</li>
                <li>Back rank mapping:</li>
                <li style={{ marginLeft: '8px' }}>Rooks = <b>Goku</b> & <b>Vegeta</b></li>
                <li style={{ marginLeft: '8px' }}>Knights = <b>Gohan Kid</b> & <b>Frieza</b></li>
                <li style={{ marginLeft: '8px' }}>Bishops = <b>Majin Boo</b> & <b>Gotenks</b></li>
                <li style={{ marginLeft: '8px' }}>Queen = <b>Grand Priest</b>, King = <b>Zeno</b></li>
                <li>Pawns = Saibaman, Chiaotzu, Krillin, Tien, Whis, Yamcha, Piccolo, Android 18.</li>
                <li>Promotions become <b>Grand Priest</b>.</li>
                </ul>
            </Panel>

            <Panel title="Assets">
                <div style={{ fontSize: '12px', opacity: 0.9 }}>
                Place sprites as PNGs:
                <pre style={{ marginTop: '8px', background: '#0b1220', padding: '8px', borderRadius: '8px' }}>assets/pieces/goku/base.png, kaioken.png, ssj.png, ...
            assets/pieces/vegeta/base.png, ssj.png, ssj2.png, ssb.png, ultra_ego.png
            assets/pieces/zeno/zeno.png
            assets/pieces/grand_priest/grand_priest.png
            ... (others optional)</pre>
                Missing sprites simply hide the image.
                </div>
            </Panel>
            </aside>

            {toast && (
              <div style={{position:'fixed', bottom:'16px', left:'50%', transform:'translateX(-50%)', background:'rgba(0,0,0,0.7)', padding:'8px 12px', borderRadius:'12px', fontSize:'14px', boxShadow:'0 8px 20px rgba(0,0,0,0.35)'}}>
                {toast}
              </div>
            )}
          </div>
        );
      }

      function Panel({ title, children }) {
        return (
          <div className="card">
            <div style={{fontWeight:600, marginBottom:'8px'}}>{title}</div>
            {children}
          </div>
        );
      }

      function Board({ game, roster, selected, legal, fog, onSquareClick }) {
        return (
          <div className="board">
            {RANKS.map((r, rIdx) =>
              FILES.map((f, fIdx) => {
                const sq = `${f}${r}`;
                const dark = isDark(fIdx, rIdx);
                const p = game.get(sq);
                const dbz = roster.get(sq);
                const isSel = selected === sq;
                const isLegal = legal.has(sq);
                const hide = fog && (
                  (game.turn() === 'w' && r > 4 && (!p || p.color !== 'w')) ||
                  (game.turn() === 'b' && r < 5 && (!p || p.color !== 'b'))
                );
                const teamClass = p ? (p.color === 'w' ? 'team-w' : 'team-b') : '';
                return (
                  <div
                    key={sq}
                    onClick={() => !hide && onSquareClick(sq)}
                    className={`relative square flex items-center justify-center select-none ${hide ? 'cursor-not-allowed' : 'cursor-pointer'} ${dark ? 'dark' : 'light'} ${isSel ? 'highlight' : ''} ${teamClass}`}
                    style={{position:'relative', display:'flex', alignItems:'center', justifyContent:'center'}}
                  >
                    {hide && <div className="absolute inset-0 mask" style={{position:'absolute', inset:0}}></div>}
                    {isLegal && !p && !hide && <div className="absolute inset-0 legal-dot" style={{position:'absolute', inset:0}} />}
                    {isLegal && p && !hide && <div className="absolute inset-0 capture-ring" style={{position:'absolute', inset:0}} />}

                    {p && dbz && !hide && (
                        <>
                        <div className="team-ring" />
                        <div className="piece-layer">
                            <img
                            className="piece-img"
                            draggable="false"
                            src={spriteUrl(dbz.char, dbz.forms[dbz.formIdx])}
                            onError={(e) => { e.currentTarget.style.display = 'none'; }}
                            alt={`${dbz.char} ${dbz.forms[dbz.formIdx]}`}
                            />
                        </div>
                        <div className="piece-badge">
                            {dbz.forms[dbz.formIdx]} · ❤{dbz.life}
                        </div>
                        </>

                    )}
                  </div>
                );
              })
            )}
          </div>
        );
      }

        // Safe mount with diagnostics
        window.__mountApp = function () {
        try {
            if (!window.Chess) throw new Error('Chess not loaded');
            const rootEl = document.getElementById('root');
            if (!rootEl) throw new Error('#root not found');
            ReactDOM.createRoot(rootEl).render(<App />);
            __log('Mounted OK');
        } catch (err) {
            __log('Mount failed:', err.message);
            throw err;
        }
        };

        // In case loader called us before DOMContentLoaded, delay a tick
        setTimeout(() => {
        try { window.__mountApp(); } catch(_) {}
        }, 0);

    }
  </script>

  <!-- ES Module loader for chess.js (single source of truth) -->
  <script type="module">
    async function loadChessAndBoot() {
        const tryImport = async (url) => {
        __log('Importing', url);
        const m = await import(url);
        return m.Chess || m.default || m;
        };

        let ChessCtor = null;

        // 1) ESM path (modern)
        try {
        ChessCtor = await tryImport('https://cdn.jsdelivr.net/npm/chess.js@1.4.0/dist/esm/chess.js');
        } catch (e1) {
        try {
            ChessCtor = await tryImport('https://unpkg.com/chess.js@1.4.0/dist/esm/chess.js');
        } catch (e2) {
            __log('ESM failed, falling back to UMD…');
            // 2) Legacy UMD fallback (0.10.3) – attaches global `Chess`
            await new Promise((resolve, reject) => {
            const s = document.createElement('script');
            s.src = 'https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js';
            s.onload = resolve;
            s.onerror = reject;
            document.head.appendChild(s);
            });
            ChessCtor = window.Chess;
            // Patch legacy to v1-like surface (minimal shims we use)
            if (ChessCtor) {
            __log('UMD loaded');
            const _proto = ChessCtor.prototype;
            _proto.isGameOver = _proto.game_over;
            _proto.isCheck = _proto.in_check;
            _proto.isCheckmate = _proto.in_checkmate;
            _proto.isStalemate = _proto.in_stalemate;
            _proto.isDraw = _proto.in_draw;
            }
        }
        }

        if (!ChessCtor) {
        __log('Chess undefined after loads');
        alert('Failed to load chess.js');
        return;
        }

        window.Chess = ChessCtor;
        __log('Chess ready');

        if (typeof window.bootDBZ === 'function') {
        __log('Calling bootDBZ');
        window.bootDBZ();
        } else {
        __log('bootDBZ not defined yet; retrying shortly…');
        let tries = 0;
        const t = setInterval(() => {
            tries++;
            if (typeof window.bootDBZ === 'function') {
            clearInterval(t);
            __log('bootDBZ found (retry)', tries);
            window.bootDBZ();
            } else if (tries > 20) {
            clearInterval(t);
            alert('App boot function missing');
            __log('bootDBZ missing after retries');
            }
        }, 100);
        }

    }

    loadChessAndBoot();
  </script>

  <script>
    console.log('Booting DBZ Chess…'); __log('Booting…');
  </script>

</body>
</html>
