<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DragonBall Chess — Local 2P</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Local vendor scripts (no network required) -->
  <script src="vendor/react.development.js"></script>
  <script src="vendor/react-dom.development.js"></script>
  <script src="vendor/babel.min.js"></script>

    <style>
    #bootlog {
        position: fixed;
        right: 8px;
        bottom: 8px;
        z-index: 9999;
        background: rgba(0, 0, 0, 0.7);
        color: #e2e8f0;
        font: 12px/1.4 ui-sans-serif, system-ui;
        padding: 8px 10px;
        border-radius: 8px;
        max-width: 60vw;
    }
    </style>

    <script>
    (function () {
        const box = document.createElement('div');
        box.id = 'bootlog';
        box.textContent = 'Boot: init';
        document.addEventListener('DOMContentLoaded', () => document.body.appendChild(box));
        window.__log = (...a) => {
        box.textContent = a.join(' | ');
        console.log('[DBZ]', ...a);
        };
        window.addEventListener('error', e => {
        __log('ERROR', e.message);
        });
    })();
    </script>

  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #0f172a; color: #e2e8f0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .square { aspect-ratio: 1 / 1; position: relative; }
    .light { background: #f0d9b5; }
    .dark { background: #b58863; }
    .highlight { outline: 3px solid rgba(255, 230, 0, 0.8); outline-offset: -3px; }
    .legal-dot::after {
      content: ""; width: 18px; height: 18px; border-radius: 9999px; background: rgba(0,0,0,0.18); position: absolute; inset: 0; margin: auto;
    }
    .capture-ring::after {
      content: ""; position: absolute; inset: 6px; border: 3px solid rgba(220,38,38,0.85); border-radius: 8px;
    }
    .mask { background: rgba(2,6,23,0.78); }
    /* Piece rendering: fill the square and keep label as overlay, so layout never stretches the square */
    .piece-layer {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 6%;           /* tasteful margin inside the square */
    pointer-events: none;  /* clicks go to the square */
    }

    .piece-img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    user-select: none;
    display: block;
    }

    .piece-badge {
    position: absolute;
    left: 0;
    right: 0;
    bottom: 4px;
    text-align: center;
    font-size: 12px;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 2px rgba(0,0,0,0.9);
    background: rgba(0,0,0,0.6);
    border-radius: 9999px;
    padding: 2px 6px;
    max-width: 90%;
    margin: 0 auto;
    pointer-events: none;
    backdrop-filter: blur(3px);

    /* color: rgba(226, 232, 240, 0.95); */
    pointer-events: none;
    }

    /* --- Team visuals --- */
    .team-w .piece-img {
    /* soft blue aura for White */
    filter: drop-shadow(0 0 6px rgba(96,165,250,0.9))
    drop-shadow(0 0 16px rgba(147,197,253,0.7));
    }

    .team-b .piece-img {
    /* soft red aura for Black */
    filter: drop-shadow(0 0 6px rgba(248,113,113,0.9))
    drop-shadow(0 0 16px rgba(254,202,202,0.7));
    }

    .team-ring {
    position: absolute;
    inset: 5px;
    border-radius: 10px;
    pointer-events: none;
    }

    .team-w .team-ring {
    border: 3px solid rgba(59,130,246,0.85);
    box-shadow: 0 0 10px rgba(59,130,246,0.45) inset;
    }

    .team-b .team-ring {
    border: 3px solid rgba(239,68,68,0.85);
    box-shadow: 0 0 10px rgba(239,68,68,0.45) inset;
    }

    .team-w .piece-badge {
    background: rgba(59,130,246,0.22);
    border-radius: 9999px;
    display: inline-block;
    padding: 2px 6px;
    }

    .team-b .piece-badge {
    background: rgba(239,68,68,0.22);
    border-radius: 9999px;
    display: inline-block;
    padding: 2px 6px;
    }

    .pulse { animation: pulseScale 320ms ease-out; }
    @keyframes pulseScale {
      0% { transform: scale(0.82); opacity: 0.65; filter: saturate(0.6) brightness(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }

    /* Minimal layout so Tailwind is not required */
    .container { max-width: 1080px; margin: 0 auto; padding: 16px; display: grid; gap: 16px; grid-template-columns: 1fr 320px; }
    .card { background: rgba(30,41,59,0.4); border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
    .board { display: grid; grid-template-columns: repeat(8, 1fr); border: 4px solid #334155; border-radius: 12px; overflow: hidden; }
    .btn { background:#334155; color:#e2e8f0; border:0; border-radius:10px; padding:8px 12px; cursor:pointer; }
    .btn:hover { background:#475569; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .status { font-size: 14px; opacity: 0.9; }
    .stack { display:grid; gap:16px; }
  </style>
</head>
<body>
  <div id="root" class="min-h-full flex items-center justify-center p-4"></div>

  <!-- App -->
  <script type="text/babel" data-presets="env,react">
    window.bootDBZ = function () {
      if (!window.Chess) { __log('bootDBZ called but Chess missing'); }
      if (!window.React || !window.ReactDOM) { __log('React/ReactDOM missing'); }

      const { useState, useEffect, useRef } = React;

      // ---------- Helpers ----------
      const FILES = ['a','b','c','d','e','f','g','h'];
      const RANKS = [8,7,6,5,4,3,2,1];
      const isDark = (fileIdx, rankIdx) => (fileIdx + rankIdx) % 2 !== 0;

      // DBZ forms (expand later with sprites)
      const FORMS = {
        goku: ['base', 'kaioken', 'ssj','ssj2','ssj3', 'ssj4', 'ssg', 'ssb', 'ssb_kaioken', 'ui','mui'],
        vegeta: ['base','great_ape', 'ssj','ssj2','ssj3', 'ssj4', 'ssg', 'ssb', 'ssb_evolved', 'ultra_ego'],
        zeno: ['zeno'],
        whis: ['angel'],
        grand_priest: ['grand_priest'],
        piccolo: ['base','potential','orange'],
        krillin: ['base'],
        yamcha: ['base'],
        tien: ['base'],
        chiaotzu: ['base'],
        android_18: ['base'],
        majin_boo: ['fat','evil','super','buutenks','buuccolo','buuhan','kid_buu'],
        frieza: ['1','2','3','final','mecha','golden','black'],
        saibaman: ['base'],
        gohan_kid: ['base','ssj','ssj2', 'ssj3', 'mystic', 'beast'],
        gotenks: ['base','ssj', 'ssj2', 'ssj3'],
      };

      function spriteUrl(char, formKey) { return `assets/pieces/${char}/${formKey}.png`; }

      function initialRoster() {
        const m = new Map(); // square -> PieceState
        // White back rank (a1..h1):
        // R: Goku, N: Gohan Kid, B: Majin Boo, Q: Grand Priest, K: Zeno, B: Gotenks, N: Frieza, R: Vegeta
        m.set('a1', mk('w','goku'));         // rook
        m.set('b1', mk('w','gohan_kid'));    // knight
        m.set('c1', mk('w','majin_boo'));    // bishop
        m.set('d1', mk('w','grand_priest')); // queen
        m.set('e1', mk('w','zeno'));         // king
        m.set('f1', mk('w','gotenks'));      // bishop
        m.set('g1', mk('w','frieza'));       // knight
        m.set('h1', mk('w','vegeta'));       // rook

        // White pawns (a2..h2):
        // Saibaman, Chiaotzu, Krillin, Tien, Whis, Yamcha, Piccolo, Android 18
        ['a2','b2','c2','d2','e2','f2','g2','h2'].forEach((sq, i) => {
        const order = ['saibaman','chiaotzu','krillin','tien','whis','yamcha','piccolo','android_18'];
        m.set(sq, mk('w', order[i]));
        });

        // Black back rank (a8..h8) mirrored with same mapping
        m.set('a8', mk('b','goku'));         // rook
        m.set('b8', mk('b','gohan_kid'));    // knight
        m.set('c8', mk('b','majin_boo'));    // bishop
        m.set('d8', mk('b','grand_priest')); // queen
        m.set('e8', mk('b','zeno'));         // king
        m.set('f8', mk('b','gotenks'));      // bishop
        m.set('g8', mk('b','frieza'));       // knight
        m.set('h8', mk('b','vegeta'));       // rook

        // Black pawns (a7..h7) same order as white
        ['a7','b7','c7','d7','e7','f7','g7','h7'].forEach((sq, i) => {
        const order = ['saibaman','chiaotzu','krillin','tien','whis','yamcha','piccolo','android_18'];
        m.set(sq, mk('b', order[i]));
        });

        return m;

        function mk(color, char) {
          const forms = FORMS[char] ?? ['base'];
          return { id: `${color}_${char}_${Math.random().toString(36).slice(2,9)}`, color, char, life: 0, kills: 0, formIdx: 0, forms };
        }
      }

      // ---------- Main App ----------
      function App() {
        // Chess & game state
        const [game, setGame] = useState(() => new Chess());
        const [roster, setRoster] = useState(() => initialRoster());
        const [selected, setSelected] = useState(null);
        const [legal, setLegal] = useState(new Set());
        const [status, setStatus] = useState('');
        const fenBefore = useRef('');

        // UI helpers
        const [toast, setToast] = useState(null);
        const [fog, setFog] = useState(false);
        const trailRef = useRef(null);

        // DBZ-aware undo
        const historyRef = useRef([]); // stack of { fenBefore, rosterBefore }
        // --------- AI / Stockfish state ----------
        const [aiWhite, setAiWhite] = useState(false);
        const [aiBlack, setAiBlack] = useState(false);
        const [eloW, setEloW] = useState(1350);    // White engine strength
        const [eloB, setEloB] = useState(1350);    // Black engine strength
        const [depth, setDepth] = useState(14);    // fallback depth cap
        const [moveMs, setMoveMs] = useState(800); // think time per move
        const [threads, setThreads] = useState(1); // NNUE single build ignores >1
        const [hashMB, setHashMB] = useState(16);
        const [engineReady, setEngineReady] = useState(false);
        const [engineThinks, setEngineThinks] = useState(false);
        const engineRef = useRef(null);            // Worker
        const engineBuf = useRef([]);              // optional logs
        const pendingBest = useRef(null);
        const thinkWatchdog = useRef(null);

        function logEngine(side, text) {
          const line = `[${new Date().toLocaleTimeString()}] ${side}: ${text}`;
          engineBuf.current.push(line);
          if (engineBuf.current.length > 60) engineBuf.current.splice(0, engineBuf.current.length - 60);
          __log(text);
        }

        useEffect(() => { refreshStatus(); maybeEngineTurn();}, []);

        function refreshStatus() {
        if (game.isGameOver()) {
            if (game.isCheckmate()) setStatus(`Checkmate — ${game.turn() === 'w' ? 'Black' : 'White'} wins`);
            else if (game.isStalemate()) setStatus('Stalemate');
            else if (game.isDraw()) setStatus('Draw');
            else setStatus('Game over');
        } else {
            const t = game.turn() === 'w' ? 'White' : 'Black';
            const flags = [ game.isCheck() ? 'Check' : null ].filter(Boolean).join(' • ');
            setStatus(`${t} to move${flags ? ' — ' + flags : ''}`);
        }
        }

        function flashNotice(msg) { setToast(msg); setTimeout(() => setToast(null), 1200); }

        // --- Attack line (blue for current player / white, red for opponent / black) ---
        function drawAttackLine(move, attackerColor) {
          if (!trailRef.current) return;
          const canvas = trailRef.current;
          const ctx = canvas.getContext('2d');
          const size = canvas.clientWidth;
          const dpr = window.devicePixelRatio || 1;
          canvas.width = size * dpr; canvas.height = size * dpr; ctx.scale(dpr, dpr);
          ctx.clearRect(0,0,size,size);
          const fromFile = FILES.indexOf(move.from[0]);
          const fromRank = 8 - parseInt(move.from[1]);
          const toFile = FILES.indexOf(move.to[0]);
          const toRank = 8 - parseInt(move.to[1]);
          const sqSize = size / 8;
          // Blue for "my" attack (white), Red for "enemy" attack (black)
          ctx.strokeStyle = attackerColor === 'w' ? '#38bdf8' : '#ef4444';
          ctx.lineWidth = 6;
          ctx.lineCap = 'round';
          ctx.shadowColor = ctx.strokeStyle;
          ctx.shadowBlur = 12;
          ctx.beginPath();
          ctx.moveTo(fromFile * sqSize + sqSize/2, fromRank * sqSize + sqSize/2);
          ctx.lineTo(toFile * sqSize + sqSize/2, toRank * sqSize + sqSize/2);
          ctx.stroke();
          setTimeout(() => { ctx.clearRect(0,0,size,size); }, 700);
        }

        // --- History helpers ---
        function pushHistory(fenBefore) {
          historyRef.current.push({ fenBefore, rosterBefore: new Map(roster) });
        }
        function popHistory() {
          const entry = historyRef.current.pop();
          if (!entry) return false;
          setGame(new Chess(entry.fenBefore));
          setRoster(entry.rosterBefore);
          setSelected(null); setLegal(new Set());
          return true;
        }
        
        function toggleTurnFen(fen, attackerColor) {
        // fen: <piece placement> <activeColor> <castling> <ep> <halfmove> <fullmove>
        const parts = fen.split(' ');
        if (parts.length < 6) return fen;
        const wasBlack = attackerColor === 'b';
        parts[1] = parts[1] === 'w' ? 'b' : 'w';
        // Increment fullmove count only after a black action completes (mirrors chess FEN)
        if (wasBlack) parts[5] = String(parseInt(parts[5], 10) + 1);
        return parts.join(' ');
        }

        // --- Input handling ---
        function onSquareClick(sq) {
          if (selected === null) {
            const p = game.get(sq); if (!p) return; if (p.color !== game.turn()) return;
            setSelected(sq);
            const moves = game.moves({ square: sq, verbose: true }).map(m => m.to);
            setLegal(new Set(moves));
            fenBefore.current = game.fen();
            return;
          }
          const pieceAt = game.get(sq);
          if (pieceAt && pieceAt.color === game.turn()) {
            setSelected(sq);
            const moves = game.moves({ square: sq, verbose: true }).map(m => m.to);
            setLegal(new Set(moves));
            fenBefore.current = game.fen();
            return;
          }
          if (legal.has(sq)) doMove(selected, sq);
          setSelected(null); setLegal(new Set());
        }

        // --- Core move pipeline (DBZ rules + chess.js) ---
        function doMove(from, to, promotion) {
          const beforeFEN = fenBefore.current || game.fen();
          pushHistory(beforeFEN);

          const attempted = game.move({ from, to, promotion: promotion || 'q' });
          if (!attempted) { setGame(new Chess(game.fen())); historyRef.current.pop(); return; }
          const wasCapture = !!attempted.captured || attempted.flags.includes('e');
          const isPromotion = !!attempted.promotion;

          // En passant defender square
          let defenderSquare = to;
          if (attempted.flags.includes('e')) {
            defenderSquare = attempted.color === 'w' ? to[0] + (parseInt(to[1]) - 1) : to[0] + (parseInt(to[1]) + 1);
          }

          if (!wasCapture) {
            // Handle promotion reskin if happened on a quiet move
            if (isPromotion) {
              const mover = roster.get(from);
              if (mover) {
                const promoted = { ...mover, char: 'grand_priest', forms: ['grand_priest'], formIdx: 0 };
                const newRoster = new Map(roster);
                newRoster.delete(from); newRoster.set(to, promoted); setRoster(newRoster);
                const moverChar = mover.char; if (moverChar === 'goku' || moverChar === 'vegeta') drawTrail({from, to}, moverChar);
                refreshStatus(); maybeEngineTurn(); return;
              }
            }
            // Regular quiet move
            syncRosterOnMove(from, to);
            refreshStatus(); maybeEngineTurn(); return;
          }

          // Capture handling — check downgrade rule
          const defenderState = roster.get(defenderSquare);
          if (defenderState && defenderState.life > 0) {
            drawAttackLine({ from, to: defenderSquare }, attempted.color);
            const downgraded = { ...defenderState };
            downgraded.life = Math.max(0, downgraded.life - 1);
            downgraded.formIdx = Math.max(0, downgraded.formIdx - 1);

            const newRoster = new Map(roster);
            newRoster.set(defenderSquare, downgraded);
            setRoster(newRoster);

            // Restore board to pre-move position but flip turn to the opponent.
            const toggledFen = toggleTurnFen(beforeFEN, attempted.color);
            const reverted = new Chess(toggledFen);
            setGame(reverted);

            flashNotice(`Downgrade! ${defenderState.char.toUpperCase()} loses a form — turn passes.`);
            refreshStatus(); maybeEngineTurn(); return;

          }

          // Defender at base — proceed with capture, attacker upgrades
          const moverState = roster.get(from);
          if (moverState) {
            drawAttackLine({ from, to: defenderSquare }, attempted.color);
            const boosted = { ...moverState };
            const defenderKills = defenderState?.kills || 0;
            boosted.life += defenderKills + 1; // opponent's kills + 1
            boosted.kills = (boosted.kills || 0) + 1; // record this kill; 

           if (boosted.formIdx < boosted.forms.length - 1) boosted.formIdx += 1;
           if (isPromotion) { boosted.char = 'grand_priest'; boosted.forms = ['grand_priest']; boosted.formIdx = 0; }

            const newRoster = new Map(roster);
            newRoster.delete(from); newRoster.set(to, boosted);
            if (attempted.flags.includes('e')) newRoster.delete(defenderSquare);
            setRoster(newRoster);
          } else {
            syncRosterOnMove(from, to);
          }
          flashNotice('Power up!');
          refreshStatus(); maybeEngineTurn();
        }

        function syncRosterOnMove(from, to) {
          const st = roster.get(from); if (!st) return;
          const newRoster = new Map(roster); newRoster.delete(from); newRoster.set(to, st); setRoster(newRoster);
        }

        // ---------- ENGINE WIRING ----------
        function isAiTurn() {
          const t = game.turn();
          return (t === 'w' && aiWhite) || (t === 'b' && aiBlack);
        }

        function bootEngine() {
        // Close old
        if (engineRef.current) {
            try { engineRef.current.terminate(); } catch(_) {}
        }
        setEngineReady(false);
        setEngineThinks(false);
        pendingBest.current = null;
        if (thinkWatchdog.current) { clearTimeout(thinkWatchdog.current); thinkWatchdog.current = null; }
        engineBuf.current = [];


        // Pick a compact single-threaded build that works without CORS gymnastics
        const workerURL = 'https://unpkg.com/stockfish@17.0.0/src/stockfish-nnue-17-lite-single.js';
        const w = new Worker(workerURL);
        engineRef.current = w;

          w.onerror = (e) => {
            logEngine('ERR', `Worker error: ${e.message || e.filename || 'unknown'}`);
          };

        w.onmessage = (e) => {
            const line = (typeof e.data === 'string') ? e.data : (e.data?.data ?? '');
            if (!line) return;

            engineBuf.current.push(line);
            logEngine('ENG', line);

            if (line === 'uciok') {
            // Send options after uci handshake
            post(`setoption name Threads value ${threads}`);
            post(`setoption name Hash value ${hashMB}`);
            post('isready');
            } else if (line === 'readyok') {
            setEngineReady(true);
            maybeEngineTurn();
            } else if (line.startsWith('bestmove')) {
            const parts = line.split(' ');
            const uci = parts[1]; // e.g., e2e4, e7e8q
            pendingBest.current = uci;
            setEngineThinks(false);
            if (thinkWatchdog.current) { clearTimeout(thinkWatchdog.current); thinkWatchdog.current = null; }
            applyBestMove();
            }
        };

        // Start UCI
        post('uci');

        function post(s) {
            try { w.postMessage(s); }
            catch (e) { console.error('Engine post fail', e); }
        }
        }

        function applyStrengthFor(color) {
          const elo = color === 'w' ? eloW : eloB;
          if (!engineRef.current) return;
          engineRef.current.postMessage(`setoption name UCI_LimitStrength value true`);
          engineRef.current.postMessage(`setoption name UCI_Elo value ${elo}`);
          // Fallback skill level mapping (some builds still accept it)
          const skill = Math.min(20, Math.max(0, Math.round((elo - 800) / 100)));
          engineRef.current.postMessage(`setoption name Skill Level value ${skill}`);
        }

        function enginePositionAndGo() {
        if (!engineRef.current || !engineReady) return;
        const fen = game.fen();
        applyStrengthFor(game.turn());
        engineRef.current.postMessage(`position fen ${fen}`);
        if (moveMs && moveMs > 0) {
            engineRef.current.postMessage(`go movetime ${moveMs}`);
        } else {
            engineRef.current.postMessage(`go depth ${depth}`);
        }
        setEngineThinks(true);
        }

        function applyBestMove() {
        const uci = pendingBest.current;
        if (!uci) return;

        const from = uci.slice(0, 2);
        const to   = uci.slice(2, 4);
        const prom = uci.length > 4 ? uci[4] : undefined;

        doMove(from, to, prom);
        pendingBest.current = null;

        if (mode === 'aivai' && !game.isGameOver()) {
            setTimeout(enginePositionAndGo, 50);
        }
        }

        function maybeEngineTurn() {
        if (!isAiTurn()) return;
        if (!engineRef.current || !engineReady) bootEngine();
        else enginePositionAndGo();
        }

        // Reconfigure on difficulty/limits change
        useEffect(() => {
        if (!engineRef.current) return;
        bootEngine();
        // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [depth, moveMs, threads, hashMB]);

        // If mode changes, possibly hand turn to engine
        useEffect(() => { maybeEngineTurn(); /* eslint-disable-next-line */ }, [aiWhite, aiBlack, game, roster]);
        // ---- UI ----
        return (
          <div className="container">
            <div className="card">
              <div style={{fontSize:'20px', fontWeight:600, marginBottom:'12px'}}>DragonBall Chess</div>
              <div className="relative">
                <Board game={game} roster={roster} selected={selected} legal={legal} fog={fog} onSquareClick={onSquareClick} />
                <div style={{position:'absolute', inset:0, pointerEvents:'none'}}>
                  <canvas ref={trailRef} className="w-full h-full pointer-events-none" />
                </div>
                {engineThinks && (
                  <div
                    style={{
                      position: 'absolute',
                      right: '8px',
                      top: '8px',
                      background: 'rgba(2,6,23,0.7)',
                      padding: '6px 10px',
                      borderRadius: '10px',
                      fontSize: '12px'
                    }}
                  >
                    Stockfish thinking…
                  </div>
                )}

              </div>
              <div className="row" style={{marginTop:'16px', justifyContent:'space-between'}}>
                <div className="status">{status}</div>
                <div className="row">
                  <button className="btn" onClick={() => { const g = new Chess(); setGame(g); setRoster(initialRoster()); setSelected(null); setLegal(new Set()); historyRef.current = []; refreshStatus(); maybeEngineTurn(); }}>Restart</button>
                  <button className="btn" onClick={() => { if (!popHistory()) return; refreshStatus(); maybeEngineTurn();}}>Undo</button>
                  <button className="btn" onClick={() => setFog(f => !f)}>{fog ? 'Fog: ON' : 'Fog: OFF'}</button>
                </div>
              </div>
            </div>

            <aside className="stack">
            <Panel title="Engine Log">
              <div style={{fontSize:12, maxHeight:180, overflow:'auto', background:'#0b1220', padding:8, borderRadius:8}}>
                {(engineBuf.current || []).map((l,i) => <div key={i} style={{whiteSpace:'pre-wrap'}}>{l}</div>)}
              </div>
              <div style={{fontSize:12, opacity:.9, marginTop:6}}>
                Ready: <b>{String(engineReady)}</b> · Thinking: <b>{String(engineThinks)}</b><br/>
                FEN: <code style={{fontSize:11}}>{game.fen()}</code>
              </div>
            </Panel>

            <Panel title="Engine / Sides">
                <div className="row" style={{ alignItems: 'center' }}>
                <label style={{ fontSize: 12, opacity: 0.9, width: 90 }}>AI as White</label>
                <input type="checkbox" checked={aiWhite} onChange={e => setAiWhite(e.target.checked)} />
                <input type="range" min="800" max="2800" step="50" value={eloW} onChange={e => setEloW(parseInt(e.target.value))} />
                <div style={{ fontSize: 12, width: 54, textAlign: 'right' }}>{eloW}</div>
                </div>
                <div className="row" style={{ alignItems: 'center' }}>
                <label style={{ fontSize: 12, opacity: 0.9, width: 90 }}>AI as Black</label>
                <input type="checkbox" checked={aiBlack} onChange={e => setAiBlack(e.target.checked)} />
                <input type="range" min="800" max="2800" step="50" value={eloB} onChange={e => setEloB(parseInt(e.target.value))} />
                <div style={{ fontSize: 12, width: 54, textAlign: 'right' }}>{eloB}</div>
                </div>
                <div className="row" style={{ marginTop: 8 }}>
                <label style={{ fontSize: 12, opacity: 0.9 }}>Time (ms)</label>
                <input type="number" className="btn" style={{ width: 100 }} value={moveMs} onChange={e => setMoveMs(parseInt(e.target.value) || 0)} />
                <label style={{ fontSize: 12, opacity: 0.9 }}>Depth</label>
                <input type="number" className="btn" style={{ width: 72 }} value={depth} onChange={e => setDepth(Math.max(1, parseInt(e.target.value) || 1))} />
                </div>
                <div className="row">
                <label style={{ fontSize: 12, opacity: 0.9 }}>Threads</label>
                <input type="number" className="btn" style={{ width: 64 }} value={threads} onChange={e => setThreads(Math.max(1, parseInt(e.target.value) || 1))} />
                <label style={{ fontSize: 12, opacity: 0.9 }}>Hash MB</label>
                <input type="number" className="btn" style={{ width: 64 }} value={hashMB} onChange={e => setHashMB(Math.max(1, parseInt(e.target.value) || 1))} />
                <button className="btn" onClick={bootEngine} disabled={engineThinks}>Reload Engine</button>
                </div>
                <div style={{ fontSize: 12, opacity: 0.85, marginTop: 6 }}>
                Tip: use separate Elo sliders per side. Set Time=0 for fixed-depth play.
                </div>
            </Panel>

            <Panel title="Turn / State">
                <div className="text-sm leading-relaxed">
                <div><b>Side:</b> {game.turn() === 'w' ? 'White' : 'Black'}</div>
                <div><b>Check:</b> {game.isCheck() ? 'Yes' : 'No'}</div>
                <div><b>Stalemate:</b> {game.isStalemate() ? 'Yes' : 'No'}</div>
                <div><b>Castling Rights:</b> <code style={{ fontSize: '12px' }}>{game.fen().split(' ')[2]}</code></div>
                <div><b>En Passant:</b> <code style={{ fontSize: '12px' }}>{game.fen().split(' ')[3]}</code></div>
                </div>
            </Panel>

            <Panel title="DBZ Rules (active)">
                <ul style={{ paddingLeft: '18px', fontSize: '14px', lineHeight: 1.5 }}>
                <li>On kill: attacker <b>life+1</b> & transforms.</li>
                <li>On hit when defender has life &gt; 0: defender <b>life-1</b>, positions unchanged, <b>turn passes to the opponent</b>.</li>
                <li>Base defender on hit: captured normally.</li>
                <li>Back rank mapping:</li>
                <li style={{ marginLeft: '8px' }}>Rooks = <b>Goku</b> & <b>Vegeta</b></li>
                <li style={{ marginLeft: '8px' }}>Knights = <b>Gohan Kid</b> & <b>Frieza</b></li>
                <li style={{ marginLeft: '8px' }}>Bishops = <b>Majin Boo</b> & <b>Gotenks</b></li>
                <li style={{ marginLeft: '8px' }}>Queen = <b>Grand Priest</b>, King = <b>Zeno</b></li>
                <li>Pawns = Saibaman, Chiaotzu, Krillin, Tien, Whis, Yamcha, Piccolo, Android 18.</li>
                <li>Promotions become <b>Grand Priest</b>.</li>
                </ul>
            </Panel>

            <Panel title="Assets">
                <div style={{ fontSize: '12px', opacity: 0.9 }}>
                Place sprites as PNGs:
                <pre style={{ marginTop: '8px', background: '#0b1220', padding: '8px', borderRadius: '8px' }}>assets/pieces/goku/base.png, kaioken.png, ssj.png, ...
            assets/pieces/vegeta/base.png, ssj.png, ssj2.png, ssb.png, ultra_ego.png
            assets/pieces/zeno/zeno.png
            assets/pieces/grand_priest/grand_priest.png
            ... (others optional)</pre>
                Missing sprites simply hide the image.
                </div>
            </Panel>
            </aside>

            {toast && (
              <div style={{position:'fixed', bottom:'16px', left:'50%', transform:'translateX(-50%)', background:'rgba(0,0,0,0.7)', padding:'8px 12px', borderRadius:'12px', fontSize:'14px', boxShadow:'0 8px 20px rgba(0,0,0,0.35)'}}>
                {toast}
              </div>
            )}
          </div>
        );
      }

      function Panel({ title, children }) {
        return (
          <div className="card">
            <div style={{fontWeight:600, marginBottom:'8px'}}>{title}</div>
            {children}
          </div>
        );
      }

      function Board({ game, roster, selected, legal, fog, onSquareClick }) {
        return (
          <div className="board">
            {RANKS.map((r, rIdx) =>
              FILES.map((f, fIdx) => {
                const sq = `${f}${r}`;
                const dark = isDark(fIdx, rIdx);
                const p = game.get(sq);
                const dbz = roster.get(sq);
                const isSel = selected === sq;
                const isLegal = legal.has(sq);
                const hide = fog && (
                  (game.turn() === 'w' && r > 4 && (!p || p.color !== 'w')) ||
                  (game.turn() === 'b' && r < 5 && (!p || p.color !== 'b'))
                );
                const teamClass = p ? (p.color === 'w' ? 'team-w' : 'team-b') : '';
                return (
                  <div
                    key={sq}
                    onClick={() => !hide && onSquareClick(sq)}
                    className={`relative square flex items-center justify-center select-none ${hide ? 'cursor-not-allowed' : 'cursor-pointer'} ${dark ? 'dark' : 'light'} ${isSel ? 'highlight' : ''} ${teamClass}`}
                    style={{position:'relative', display:'flex', alignItems:'center', justifyContent:'center'}}
                  >
                    {hide && <div className="absolute inset-0 mask" style={{position:'absolute', inset:0}}></div>}
                    {isLegal && !p && !hide && <div className="absolute inset-0 legal-dot" style={{position:'absolute', inset:0}} />}
                    {isLegal && p && !hide && <div className="absolute inset-0 capture-ring" style={{position:'absolute', inset:0}} />}

                    {p && dbz && !hide && (
                        <>
                        <div className="team-ring" />
                        <div className="piece-layer">
                            <img
                            className="piece-img"
                            draggable="false"
                            src={spriteUrl(dbz.char, dbz.forms[dbz.formIdx])}
                            onError={(e) => { e.currentTarget.style.display = 'none'; }}
                            alt={`${dbz.char} ${dbz.forms[dbz.formIdx]}`}
                            />
                        </div>
                        <div className="piece-badge">
                            {dbz.forms[dbz.formIdx]} · ❤{dbz.life}
                        </div>
                        </>

                    )}
                  </div>
                );
              })
            )}
          </div>
        );
      }

        // Safe mount with diagnostics
        window.__mountApp = function () {
        try {
            if (!window.Chess) throw new Error('Chess not loaded');
            const rootEl = document.getElementById('root');
            if (!rootEl) throw new Error('#root not found');
            ReactDOM.createRoot(rootEl).render(<App />);
            __log('Mounted OK');
        } catch (err) {
            __log('Mount failed:', err.message);
            throw err;
        }
        };

        // In case loader called us before DOMContentLoaded, delay a tick
        setTimeout(() => {
        try { window.__mountApp(); } catch(_) {}
        }, 0);

    }
  </script>

  <!-- ES Module loader for chess.js (single source of truth) -->
  <script type="module">
    async function loadChessAndBoot() {
        const tryImport = async (url) => {
        __log('Importing', url);
        const m = await import(url);
        return m.Chess || m.default || m;
        };

        let ChessCtor = null;

        // 1) ESM path (modern)
        try {
        ChessCtor = await tryImport('https://cdn.jsdelivr.net/npm/chess.js@1.4.0/dist/esm/chess.js');
        } catch (e1) {
        try {
            ChessCtor = await tryImport('https://unpkg.com/chess.js@1.4.0/dist/esm/chess.js');
        } catch (e2) {
            __log('ESM failed, falling back to UMD…');
            // 2) Legacy UMD fallback (0.10.3) – attaches global `Chess`
            await new Promise((resolve, reject) => {
            const s = document.createElement('script');
            s.src = 'https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js';
            s.onload = resolve;
            s.onerror = reject;
            document.head.appendChild(s);
            });
            ChessCtor = window.Chess;
            // Patch legacy to v1-like surface (minimal shims we use)
            if (ChessCtor) {
            __log('UMD loaded');
            const _proto = ChessCtor.prototype;
            _proto.isGameOver = _proto.game_over;
            _proto.isCheck = _proto.in_check;
            _proto.isCheckmate = _proto.in_checkmate;
            _proto.isStalemate = _proto.in_stalemate;
            _proto.isDraw = _proto.in_draw;
            }
        }
        }

        if (!ChessCtor) {
        __log('Chess undefined after loads');
        alert('Failed to load chess.js');
        return;
        }

        window.Chess = ChessCtor;
        __log('Chess ready');

        if (typeof window.bootDBZ === 'function') {
        __log('Calling bootDBZ');
        window.bootDBZ();
        } else {
        __log('bootDBZ not defined yet; retrying shortly…');
        let tries = 0;
        const t = setInterval(() => {
            tries++;
            if (typeof window.bootDBZ === 'function') {
            clearInterval(t);
            __log('bootDBZ found (retry)', tries);
            window.bootDBZ();
            } else if (tries > 20) {
            clearInterval(t);
            alert('App boot function missing');
            __log('bootDBZ missing after retries');
            }
        }, 100);
        }

    }

    loadChessAndBoot();
  </script>

  <script>
    console.log('Booting DBZ Chess…'); __log('Booting…');
  </script>

</body>
</html>
